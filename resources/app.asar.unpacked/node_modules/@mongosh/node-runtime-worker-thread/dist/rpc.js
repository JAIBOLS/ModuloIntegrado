"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCaller = exports.exposeAll = exports.cancel = exports.close = exports.removeTrailingUndefined = exports.deserialize = exports.serialize = void 0;
const v8_1 = __importDefault(require("v8"));
const postmsg_rpc_1 = require("postmsg-rpc");
const serializer_1 = require("./serializer");
function serialize(data) {
    return `data:;base64,${v8_1.default.serialize(data).toString('base64')}`;
}
exports.serialize = serialize;
function deserialize(str) {
    if (/^data:;base64,.+/.test(str)) {
        return v8_1.default.deserialize(Buffer.from(str.replace('data:;base64,', ''), 'base64'));
    }
    return str;
}
exports.deserialize = deserialize;
var RPCMessageTypes;
(function (RPCMessageTypes) {
    RPCMessageTypes[RPCMessageTypes["Message"] = 0] = "Message";
    RPCMessageTypes[RPCMessageTypes["Error"] = 1] = "Error";
})(RPCMessageTypes || (RPCMessageTypes = {}));
function isRPCError(data) {
    return (data && typeof data === 'object' && data.type === RPCMessageTypes.Error);
}
function isMessageData(data) {
    return data && typeof data === 'object' && 'id' in data && 'sender' in data;
}
function isServerMessageData(data) {
    return isMessageData(data) && data.sender === 'postmsg-rpc/server';
}
function isClientMessageData(data) {
    return isMessageData(data) && data.sender === 'postmsg-rpc/client';
}
function removeTrailingUndefined(arr) {
    if (Array.isArray(arr)) {
        arr = [...arr];
        while (arr.length > 0 && arr[arr.length - 1] === undefined) {
            arr.pop();
        }
    }
    return arr;
}
exports.removeTrailingUndefined = removeTrailingUndefined;
function send(messageBus, data) {
    if ('postMessage' in messageBus &&
        typeof messageBus.postMessage === 'function') {
        messageBus.postMessage(data);
    }
    if ('send' in messageBus && typeof messageBus.send === 'function') {
        messageBus.send(data);
    }
}
function getRPCOptions(messageBus) {
    return {
        addListener: messageBus.on.bind(messageBus),
        removeListener: messageBus.off.bind(messageBus),
        postMessage(data) {
            if (isClientMessageData(data) && Array.isArray(data.args)) {
                data.args = serialize(removeTrailingUndefined(data.args));
            }
            if (isServerMessageData(data)) {
                try {
                    data.res = serialize(data.res);
                }
                catch (e) {
                    data.res = serialize({
                        type: RPCMessageTypes.Error,
                        payload: (0, serializer_1.serializeError)(e)
                    });
                }
            }
            return send(messageBus, data);
        },
        getMessageData(data) {
            if (isClientMessageData(data) &&
                data.args &&
                typeof data.args === 'string') {
                data.args = deserialize(data.args);
            }
            if (isServerMessageData(data) && typeof data.res === 'string') {
                data.res = deserialize(data.res);
            }
            return data;
        }
    };
}
exports.close = Symbol('@@rpc.close');
exports.cancel = Symbol('@@rpc.cancel');
function exposeAll(obj, messageBus) {
    Object.entries(obj).forEach(([key, val]) => {
        const { close } = (0, postmsg_rpc_1.expose)(key, async (...args) => {
            try {
                return { type: RPCMessageTypes.Message, payload: await val(...args) };
            }
            catch (e) {
                return { type: RPCMessageTypes.Error, payload: (0, serializer_1.serializeError)(e) };
            }
        }, getRPCOptions(messageBus));
        val.close = close;
    });
    Object.defineProperty(obj, exports.close, {
        enumerable: false,
        value() {
            Object.values(obj).forEach((fn) => {
                fn.close();
            });
        }
    });
    return obj;
}
exports.exposeAll = exposeAll;
function createCaller(methodNames, messageBus, processors = {}) {
    const obj = {};
    const inflight = new Set();
    methodNames.forEach((name) => {
        const c = (0, postmsg_rpc_1.caller)(name, getRPCOptions(messageBus));
        obj[name] = async (...args) => {
            var _a;
            const processed = typeof processors[name] === 'function'
                ? (_a = processors[name]) === null || _a === void 0 ? void 0 : _a.call(processors, ...args)
                : args;
            const promise = c(...processed);
            inflight.add(promise);
            const result = (await promise);
            inflight.delete(promise);
            if (isRPCError(result))
                throw (0, serializer_1.deserializeError)(result.payload);
            return result.payload;
        };
    });
    Object.defineProperty(obj, exports.cancel, {
        enumerable: false,
        value() {
            for (const cancelable of inflight) {
                cancelable.cancel();
                inflight.delete(cancelable);
            }
        }
    });
    return obj;
}
exports.createCaller = createCaller;
//# sourceMappingURL=rpc.js.map